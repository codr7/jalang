* add benchmark macro

* debug sum/fib
** add vm arg to operation toString
*** add abstract method to operation
*** lookup values for registers
**** value: 15 (...)
** allocate parameter registers in Sexpr.emit
*** pass to Call op instead of arity
*** move into place in Call op eval after backup in frame
** create call frames for all calls
*** remove register allocation for params in function emit

* handle user defined functions in map/reduce
** add Function.evaluate() with same args as call
*** use in map/reduce

* aoc/code1.jl

* add union types
** Integer|Null
** Add NullType
** relaxing requirements should not break callers
** strengthening promises should not break callers
** add X? as alias for X|Null

* enable using Collections as Sexpr targets
** add find method to CollectionTrait
** lookup argument using find
** add get method
*** throw exception if not found

* add let macro
** allocate registers
*** bind in namespace
** test increment/decrement

(let [x 1]
  (+1 x))

* add ordered maps
** {1 2 3:4}
** use TreeMap

* check function argument types

* turn pair into collection/sequence type
