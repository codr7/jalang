0.4520028
0.14301105

* add lookup fib test/benchmark

(function fib(n:Integer lookup:Map):Integer
  (or (lookup n)
      (lookup n (if (< n 2) n (+ (fib (-1 n) lookup)
                                 (fib (-1 n) lookup))))))

(say (benchmark 10000 (fib 70 {})))

* add and macro
* add not function

* change trait argument types to Value<?>

* hook up type hierarchy
** add type function
** add is function

* add or types
** Integer|None
** relaxing requirements should not break callers
** strengthening promises should not break callers
** add X? as alias for X|None
** change find-if resultType Any?

* convert reduce/map ops to macros like find/index-if

* add let macro

(let [x 1 y 2]
  (+ x y))

* add dynamic scope support for defines in let

* check function argument types at compile time

* turn pair into collection/sequence type

* add character literals

\a \b \\n

* add vm arg to operation toString
** add abstract method to operation
** lookup values for registers
*** value: 15 (...)