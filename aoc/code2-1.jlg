(f decode-color [in out]
  (let [n:i (parse-integer in)
        c (Symbol (slice in (+ i 1)))]
    (out c (max (or (out c) 0) n))))
  
(f decode-game [in out]
  (for [c (split in ",")]
    (decode-color c out)))
  
(f decode-line [in]
  (let [games (split (slice in (+ (_:find (f [c] (= c \:)) in) 1)) ";")
        out {}]
    (for [g games]
      (decode-game g out))
    out))
	
(f read-games [path]
  (enumerate (map decode-line (split (slurp path) "\n")) 1))

(f possible? [game]
  (not (or (> (game 'red) 12)
           (> (game 'green) 13)
           (> (game 'blue) 14))))

(f sum-games [path]
  (reduce + (map peek.peek (find-all tail.possible? (read-games path))) 0))
    
(check 2268
  (sum-games (path "input2")))